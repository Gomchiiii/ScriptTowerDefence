<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒ€ì›Œ ë””íœìŠ¤ ì½”ë”© ê²Œì„</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: #252526;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #3e3e42;
        }
        
        h1 {
            color: #4ec9b0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        h2 {
            color: #569cd6;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        #gameCanvas {
            width: 100%;
            background: #1e1e1e;
            border: 2px solid #4ec9b0;
            border-radius: 4px;
            display: block;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        
        .stat-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #4ec9b0;
            font-size: 20px;
            font-weight: bold;
        }
        
        #codeEditor {
            width: 100%;
            height: 400px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            color: #d4d4d4;
            resize: vertical;
            line-height: 1.5;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #1177bb;
        }
        
        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #c72e2e;
        }
        
        button.danger:hover {
            background: #e03e3e;
        }
        
        #output {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .log-info {
            color: #4ec9b0;
        }
        
        .log-error {
            color: #f48771;
        }
        
        .log-warning {
            color: #dcdcaa;
        }
        
        .log-success {
            color: #4ec9b0;
        }
        
        .template-info {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #569cd6;
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>ğŸ® íƒ€ì›Œ ë””íœìŠ¤ ì½”ë”© ê²Œì„</h1>
            
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">ë ˆë²¨</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">íƒ„ì•½</div>
                    <div class="stat-value" id="ammo">100</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ë°ë¯¸ì§€</div>
                    <div class="stat-value" id="damage">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ì ìˆ˜</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
            
            <div id="upgradeDisplay" style="margin: 10px 0;">
                <strong style="color: #569cd6; font-size: 14px; margin-bottom: 8px; display: block;">ğŸ´ íšë“ ì—…ê·¸ë ˆì´ë“œ</strong>
                <div id="upgradeList" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px;">
                    <div style="color: #858585; font-size: 13px; padding: 8px;">ì—†ìŒ</div>
                </div>
            </div>
            
            <div class="controls">
                <button id="runBtn">â–¶ ì‹¤í–‰</button>
                <button id="stopBtn" class="danger" disabled>â–  ì •ì§€</button>
                <button id="resetBtn">â†» ë¦¬ì…‹</button>
            </div>
            
            <h2>ğŸ“‹ ë¡œê·¸</h2>
            <div id="output"></div>
        </div>
        
        <div class="panel">
            <h2>ğŸ’» íŒŒì´ì¬ ì½”ë“œ</h2>
            
            <div class="template-info">
                <strong>ì‚¬ìš© ê°€ëŠ¥í•œ API:</strong><br>
                â€¢ <code>zombies</code> - ì¢€ë¹„ ë¦¬ìŠ¤íŠ¸ (distance, hp, type, isVulnerable ì†ì„±)<br>
                â€¢ <code>zombie.type</code> - 'basic', 'vulnerable', 'bonus', 'boss'<br>
                â€¢ <strong>â­ bonus</strong> - ë¹ ë¥¸ ì‹œì•ˆìƒ‰, ë§ì¶”ë©´ ë°ë¯¸ì§€ +1!<br>
                â€¢ <strong>ğŸ”¥ boss</strong> - 5ë ˆë²¨ë§ˆë‹¤, ê±°ëŒ€ ë³´ë¼ìƒ‰, ì²˜ì¹˜ ì‹œ ì¹´ë“œ ì„ íƒ!<br>
                â€¢ <code>tower.shoot(zombie)</code> - ì¢€ë¹„ ê°ì²´ë¡œ ê³µê²©<br>
                â€¢ <code>tower.ammo</code> - ë‚¨ì€ íƒ„ì•½<br>
                <br>
                <strong>ğŸƒ ì¹´ë“œ ì„ íƒ í•¨ìˆ˜ (ì„ íƒì‚¬í•­):</strong><br>
                â€¢ <code>on_boss_defeated(tower, cards)</code> í•¨ìˆ˜ ì •ì˜<br>
                â€¢ ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ ìë™ í˜¸ì¶œë¨<br>
                â€¢ ì„ íƒí•œ ì¹´ë“œì˜ nameì„ return
            </div>
            
            <textarea id="codeEditor" spellcheck="false"># íƒ€ì›Œ AI ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”!

def ai_logic(tower, zombies):
    """
    ë§¤ í”„ë ˆì„ë§ˆë‹¤ í˜¸ì¶œë©ë‹ˆë‹¤.
    
    ì „ëµ íŒíŠ¸:
    - bonus ì¢€ë¹„ ìš°ì„  ì²˜ì¹˜ â†’ ë°ë¯¸ì§€ ì—…ê·¸ë ˆì´ë“œ!
    - ë³´ìŠ¤ëŠ” ë°ë¯¸ì§€ ì—…ê·¸ë ˆì´ë“œ í›„ ì§‘ì¤‘ ê³µê²©
    """
    
    if not zombies or tower.ammo <= 0:
        return
    
    # ì‚¬ê±°ë¦¬ ì•ˆì˜ ì¢€ë¹„ë“¤ë§Œ í•„í„°
    in_range = [z for z in zombies if z.distance < 200]
    if not in_range:
        return
    
    # 1ìˆœìœ„: bonus ì¢€ë¹„ (ë°ë¯¸ì§€ ì—…!)
    bonus = [z for z in in_range if z.type == 'bonus']
    if bonus:
        target = min(bonus, key=lambda z: z.distance)
        tower.shoot(target)  # ì¢€ë¹„ ê°ì²´ ì „ë‹¬!
        return
    
    # 2ìˆœìœ„: vulnerable ì¢€ë¹„ (ê³µê²© ê°€ëŠ¥í•  ë•Œ)
    vulnerable = [z for z in in_range if z.type == 'vulnerable' and z.isVulnerable]
    if vulnerable:
        target = min(vulnerable, key=lambda z: z.distance)
        tower.shoot(target)  # ì¢€ë¹„ ê°ì²´ ì „ë‹¬!
        return
    
    # 3ìˆœìœ„: ê°€ì¥ ê°€ê¹Œìš´ ì¢€ë¹„
    closest = min(in_range, key=lambda z: z.distance)
    tower.shoot(closest)  # ì¢€ë¹„ ê°ì²´ ì „ë‹¬!


def on_boss_defeated(tower, cards):
    """
    ë³´ìŠ¤ ì²˜ì¹˜ ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤.
    
    Args:
        tower: íƒ€ì›Œ ìƒíƒœ (damage, ammo, maxAmmo, upgrades)
        cards: ì„ íƒ ê°€ëŠ¥í•œ ì¹´ë“œ ë¦¬ìŠ¤íŠ¸
            [{'name': 'rapid_fire', 'description': 'ğŸ”¥ ì—°ì‚¬ - ë°œì‚¬ì†ë„ +50%'}, ...]
    
    Returns:
        ì„ íƒí•œ ì¹´ë“œì˜ name (str)
    """
    
    # ì¹´ë“œ ì´ë¦„ë“¤ ì¶œë ¥
    print("=== ì¹´ë“œ ì„ íƒ ===")
    for card in cards:
        print(f"- {card.name}: {card.description}")
    
    # ì „ëµì  ì„ íƒ
    # ë°ë¯¸ì§€ê°€ ë‚®ìœ¼ë©´ í™”ë ¥ ì¦ê°•
    if tower.damage < 3:
        for card in cards:
            if card.name in ['damage_up', 'rapid_fire']:
                return card.name
    
    # íƒ„ì•½ ë¶€ì¡±í•˜ë©´ ì¬ìƒì´ë‚˜ íƒ„ì•½ê³ 
    if tower.ammo < 50:
        for card in cards:
            if card.name in ['ammo_regen', 'reload', 'max_ammo']:
                return card.name
    
    # ì•„ë‹ˆë©´ ì²« ë²ˆì§¸ ì¹´ë“œ
    return cards[0].name

# ì—¬ê¸°ì„œë¶€í„° ì»¤ìŠ¤í„°ë§ˆì´ì§• ì‹œì‘!
</textarea>
        </div>
    </div>

    <script>
        let pyodide = null;
        let gameState = null;
        let animationId = null;
        let isRunning = false;

        // ê²Œì„ ìƒíƒœ í´ë˜ìŠ¤
        class GameState {
            constructor() {
                this.level = 1;
                this.score = 0;
                this.ammo = 100;
                this.maxAmmo = 100;
                this.ammoRegenRate = 0.5;
                this.zombies = [];
                this.tower = { x: 100, y: 200 };
                this.bullets = [];
                this.frameCount = 0;
                this.spawnTimer = 0;
                this.spawnInterval = 120;
                this.shootCooldown = 0;
                this.shootCooldownTime = 30;
                this.damage = 1;
                this.bossSpawned = false;
                this.isPaused = false;  // ì¹´ë“œ ì„ íƒ ì¤‘ ì¼ì‹œì •ì§€
                this.pendingCards = null;  // ì„ íƒ ëŒ€ê¸° ì¤‘ì¸ ì¹´ë“œë“¤
                this.selectedUpgrades = {};  // ì„ íƒí•œ ì—…ê·¸ë ˆì´ë“œ ì¹´ìš´íŠ¸ {name: {description, count}}
                
                // íƒ€ì›Œ ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ
                this.towerUpgrades = {
                    hasPenetration: false,
                    hasExplosion: false,
                    hasMultiShot: false,
                    hasAutoAttack: false,
                    criticalChance: 0,
                    bonusSpawnRate: 1.0,
                    defenseBuffer: 0
                };
            }

            spawnZombie() {
                // 5ë ˆë²¨ë§ˆë‹¤ ë³´ìŠ¤ ìŠ¤í° (í•œ ë²ˆë§Œ)
                if (this.level % 5 === 0 && !this.bossSpawned) {
                    this.zombies.push({
                        x: 600,
                        y: 180,
                        hp: 15 + this.level * 2,  // ì—„ì²­ ë†’ì€ HP
                        maxHp: 15 + this.level * 2,
                        speed: 0.2,  // ëŠë¦¼
                        type: 'boss',
                        id: Date.now() + Math.random(),
                        size: 60  // í¬ê¸°
                    });
                    this.bossSpawned = true;
                    log('ğŸ”¥ ê±°ëŒ€ ì¢€ë¹„ ì¶œí˜„! ì§‘ì¤‘ ê³µê²© í•„ìš”!', 'warning');
                    return;
                }
                
                // ëœë¤ìœ¼ë¡œ ì¢€ë¹„ íƒ€ì… ì„ íƒ
                const rand = Math.random();
                
                // ë³´ë„ˆìŠ¤ ì¶œí˜„ë¥  ì—…ê·¸ë ˆì´ë“œ ì ìš©
                const bonusChance = 0.1 * this.towerUpgrades.bonusSpawnRate;
                
                if (rand < bonusChance) {
                    // 10% - ë³´ë„ˆìŠ¤ ì¢€ë¹„ (ë§ì¶”ë©´ ë°ë¯¸ì§€ ì—…ê·¸ë ˆì´ë“œ!)
                    this.zombies.push({
                        x: 600,
                        y: 150 + Math.random() * 100,
                        hp: 1,
                        maxHp: 1,
                        speed: 1.5,  // ë¹ ë¦„!
                        type: 'bonus',
                        id: Date.now() + Math.random()
                    });
                } else if (rand < 0.35) {
                    // 25% - vulnerable
                    this.zombies.push({
                        x: 600,
                        y: 150 + Math.random() * 100,
                        hp: 999,
                        maxHp: 999,
                        speed: 0.3 + this.level * 0.05,
                        type: 'vulnerable',
                        id: Date.now() + Math.random(),
                        isVulnerable: false,
                        vulnerableTimer: 0,
                        vulnerableCycle: 120
                    });
                } else {
                    // 65% - basic
                    this.zombies.push({
                        x: 600,
                        y: 150 + Math.random() * 100,
                        hp: 1,
                        maxHp: 1,
                        speed: 0.5 + this.level * 0.1,
                        type: 'basic',
                        id: Date.now() + Math.random()
                    });
                }
            }

            getRandomCards() {
                // ì¹´ë“œ í’€
                const allCards = [
                    { name: 'rapid_fire', description: 'ğŸ”¥ ì—°ì‚¬ - ë°œì‚¬ì†ë„ +50%', effect: () => {
                        this.shootCooldownTime = Math.max(10, Math.floor(this.shootCooldownTime * 0.5));
                        log('ì—°ì‚¬ ì—…ê·¸ë ˆì´ë“œ! ë°œì‚¬ì†ë„ 2ë°°!', 'success');
                    }},
                    { name: 'ammo_regen', description: 'ğŸ’° íƒ„ì•½ì¬ìƒ - ì¬ìƒì†ë„ 2ë°°', effect: () => {
                        this.ammoRegenRate *= 2;
                        log('íƒ„ì•½ ì¬ìƒì†ë„ 2ë°°!', 'success');
                    }},
                    { name: 'penetration', description: 'ğŸ¯ ê´€í†µíƒ„ - 2ë§ˆë¦¬ ê´€í†µ', effect: () => {
                        this.towerUpgrades.hasPenetration = true;
                        log('ê´€í†µíƒ„ íšë“! í•œ ë°œë¡œ 2ë§ˆë¦¬!', 'success');
                    }},
                    { name: 'explosion', description: 'ğŸ’£ í­ë°œíƒ„ - ë²”ìœ„ ë°ë¯¸ì§€', effect: () => {
                        this.towerUpgrades.hasExplosion = true;
                        log('í­ë°œíƒ„ íšë“! ê´‘ì—­ ê³µê²©!', 'success');
                    }},
                    { name: 'defense', description: 'ğŸ›¡ï¸ ë°©ì–´ë§‰ - ë²„í‹¸ìˆ˜ìˆëŠ” ì¢€ë¹„ +5', effect: () => {
                        this.towerUpgrades.defenseBuffer += 5;
                        log('ë°©ì–´ë§‰ ê°•í™”! +5 ì—¬ìœ ', 'success');
                    }},
                    { name: 'multi_shot', description: 'ğŸª ë©€í‹°ìƒ· - 3ë°œ ë™ì‹œë°œì‚¬', effect: () => {
                        this.towerUpgrades.hasMultiShot = true;
                        log('ë©€í‹°ìƒ· íšë“! 3ë°œ ë™ì‹œë°œì‚¬!', 'success');
                    }},
                    { name: 'critical', description: 'ğŸŒŸ í¬ë¦¬í‹°ì»¬ - 20% 3ë°° ë°ë¯¸ì§€', effect: () => {
                        this.towerUpgrades.criticalChance += 0.2;
                        log('í¬ë¦¬í‹°ì»¬ í™•ë¥  +20%!', 'success');
                    }},
                    { name: 'lucky', description: 'ğŸ² í–‰ìš´ - ë³´ë„ˆìŠ¤ ì¶œí˜„ 2ë°°', effect: () => {
                        this.towerUpgrades.bonusSpawnRate *= 2;
                        log('ë³´ë„ˆìŠ¤ ì¢€ë¹„ ì¶œí˜„ë¥  2ë°°!', 'success');
                    }},
                    { name: 'reload', description: 'ğŸ”„ ì¬ì¥ì „ - íƒ„ì•½ ì „ë¶€ íšŒë³µ', effect: () => {
                        this.ammo = this.maxAmmo;
                        log('íƒ„ì•½ ì „ë¶€ íšŒë³µ!', 'success');
                    }},
                    { name: 'damage_up', description: 'âš”ï¸ í™”ë ¥ì¦ê°• - ë°ë¯¸ì§€ +2', effect: () => {
                        this.damage += 2;
                        log('ë°ë¯¸ì§€ +2!', 'success');
                    }},
                    { name: 'max_ammo', description: 'ğŸ“¦ íƒ„ì•½ê³  - ìµœëŒ€íƒ„ì•½ +50', effect: () => {
                        this.maxAmmo += 50;
                        this.ammo += 50;
                        log('ìµœëŒ€ íƒ„ì•½ +50!', 'success');
                    }}
                ];
                
                // ëœë¤ 3ê°œ ì„ íƒ
                const shuffled = allCards.sort(() => Math.random() - 0.5);
                return shuffled.slice(0, 3);
            }

            applyCard(cardName) {
                const card = this.pendingCards.find(c => c.name === cardName);
                if (card) {
                    card.effect();
                    
                    // ì—…ê·¸ë ˆì´ë“œ ì¹´ìš´íŠ¸ ì¶”ê°€
                    if (!this.selectedUpgrades[cardName]) {
                        this.selectedUpgrades[cardName] = {
                            description: card.description,
                            count: 1
                        };
                    } else {
                        this.selectedUpgrades[cardName].count++;
                    }
                    
                    this.updateUpgradeDisplay();
                }
                this.pendingCards = null;
                this.isPaused = false;
            }

            updateUpgradeDisplay() {
                const upgradeList = document.getElementById('upgradeList');
                
                if (Object.keys(this.selectedUpgrades).length === 0) {
                    upgradeList.innerHTML = '<div style="color: #858585; font-size: 13px; padding: 8px;">ì—†ìŒ</div>';
                    return;
                }
                
                // ì¹´ë“œ í˜•íƒœë¡œ í‘œì‹œ
                upgradeList.innerHTML = Object.entries(this.selectedUpgrades)
                    .map(([name, data]) => {
                        const countBadge = data.count > 1 
                            ? `<span style="position: absolute; top: -8px; right: -8px; background: #c72e2e; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid #252526;">${data.count}</span>`
                            : '';
                        
                        return `
                            <div style="position: relative; background: #1e1e1e; border: 2px solid #4ec9b0; border-radius: 6px; padding: 8px 12px; font-size: 12px; color: #d4d4d4; min-width: 120px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">
                                ${countBadge}
                                ${data.description.split(' - ')[0]}
                            </div>
                        `;
                    })
                    .join('');
            }


            update(userAI) {
                // ì¹´ë“œ ì„ íƒ ì¤‘ì´ë©´ ì—…ë°ì´íŠ¸ ì•ˆí•¨
                if (this.isPaused) {
                    return;
                }
                
                this.frameCount++;
                this.spawnTimer++;
                
                // ë°œì‚¬ ì¿¨ë‹¤ìš´ ê°ì†Œ
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                }

                // ì¢€ë¹„ ìŠ¤í°
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnZombie();
                    this.spawnTimer = 0;
                }

                // íƒ„ì•½ ì¬ìƒ
                if (this.ammo < this.maxAmmo) {
                    this.ammo = Math.min(this.maxAmmo, this.ammo + this.ammoRegenRate);
                }

                // ì¢€ë¹„ ì´ë™
                for (let zombie of this.zombies) {
                    zombie.x -= zombie.speed;
                    zombie.distance = Math.sqrt(
                        Math.pow(zombie.x - this.tower.x, 2) +
                        Math.pow(zombie.y - this.tower.y, 2)
                    );
                    
                    // vulnerable íƒ€ì… ì¢€ë¹„ì˜ ìƒíƒœ í† ê¸€
                    if (zombie.type === 'vulnerable') {
                        zombie.vulnerableTimer++;
                        if (zombie.vulnerableTimer >= zombie.vulnerableCycle) {
                            zombie.isVulnerable = !zombie.isVulnerable;
                            zombie.vulnerableTimer = 0;
                        }
                    }
                }

                // íƒ„ì•½ ì´ë™
                for (let bullet of this.bullets) {
                    if (bullet.target && !bullet.target.dead) {
                        const dx = bullet.target.x - bullet.x;
                        const dy = bullet.target.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 5) {
                            const target = bullet.target;
                            
                            // vulnerable íƒ€ì…ì€ ê³µê²© ê°€ëŠ¥ ìƒíƒœì¼ ë•Œë§Œ ë°ë¯¸ì§€
                            if (target.type === 'vulnerable') {
                                if (target.isVulnerable) {
                                    target.dead = true;
                                    this.score += 20;
                                    this.ammo += 3;
                                    log('Vulnerable ì¢€ë¹„ ì²˜ì¹˜!', 'success');
                                } else {
                                    log('ê³µê²© ì‹¤íŒ¨! ì¢€ë¹„ê°€ ë¬´ì  ìƒíƒœì…ë‹ˆë‹¤.', 'warning');
                                }
                            } 
                            // ë³´ë„ˆìŠ¤ ì¢€ë¹„ - ë°ë¯¸ì§€ ì—…ê·¸ë ˆì´ë“œ!
                            else if (target.type === 'bonus') {
                                target.hp -= this.damage;
                                if (target.hp <= 0) {
                                    target.dead = true;
                                    this.damage += 1;  // ë°ë¯¸ì§€ ì¦ê°€!
                                    this.score += 50;
                                    this.ammo += 10;
                                    log(`ğŸ’¥ ë³´ë„ˆìŠ¤ íšë“! ë°ë¯¸ì§€ ${this.damage}ë¡œ ì—…ê·¸ë ˆì´ë“œ!`, 'success');
                                }
                            }
                            // ë³´ìŠ¤ ì¢€ë¹„
                            else if (target.type === 'boss') {
                                target.hp -= this.damage;
                                if (target.hp <= 0) {
                                    target.dead = true;
                                    this.score += 100;
                                    this.ammo += 20;
                                    log('ğŸ† ë³´ìŠ¤ ì²˜ì¹˜ ì„±ê³µ! ì¹´ë“œ ì„ íƒ ëŒ€ê¸°...', 'success');
                                    
                                    // ì¹´ë“œ ì„ íƒ ì‹œì‘
                                    this.isPaused = true;
                                    this.pendingCards = this.getRandomCards();
                                } else {
                                    log(`ë³´ìŠ¤ HP: ${target.hp}/${target.maxHp}`, 'info');
                                }
                            }
                            // ì¼ë°˜ ì¢€ë¹„
                            else {
                                target.hp -= this.damage;
                                if (target.hp <= 0) {
                                    target.dead = true;
                                    this.score += 10;
                                    this.ammo += 2;
                                }
                            }
                            bullet.dead = true;
                        } else {
                            bullet.x += (dx / dist) * bullet.speed;
                            bullet.y += (dy / dist) * bullet.speed;
                        }
                    } else {
                        bullet.dead = true;
                    }
                }

                // ì£½ì€ ê°ì²´ ì œê±°
                this.zombies = this.zombies.filter(z => !z.dead && z.x > -50);
                this.bullets = this.bullets.filter(b => !b.dead);

                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                const escaped = this.zombies.filter(z => z.x < this.tower.x);
                const allowedEscaped = 5 + this.towerUpgrades.defenseBuffer;
                if (escaped.length > allowedEscaped) {
                    log('ê²Œì„ ì˜¤ë²„! ì¢€ë¹„ë“¤ì´ íƒ€ì›Œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!', 'error');
                    stopGame();
                    return;
                }

                // ë ˆë²¨ì—… ì²´í¬
                if (this.score > this.level * 100) {
                    this.level++;
                    log(`ë ˆë²¨ ${this.level}!`, 'success');
                    
                    // ë‹¤ìŒ ë³´ìŠ¤ ë ˆë²¨ì„ ìœ„í•´ í”Œë˜ê·¸ ë¦¬ì…‹
                    if (this.level % 5 === 1) {
                        this.bossSpawned = false;
                    }
                }

                // ì‚¬ìš©ì AI ì‹¤í–‰
                try {
                    // ì¹´ë“œ ì„ íƒì´ í•„ìš”í•œ ê²½ìš°
                    if (this.isPaused && this.pendingCards) {
                        const cardData = this.pendingCards.map(c => ({
                            name: c.name,
                            description: c.description
                        }));
                        
                        const towerData = {
                            damage: this.damage,
                            ammo: Math.floor(this.ammo),
                            maxAmmo: this.maxAmmo,
                            upgrades: this.towerUpgrades
                        };
                        
                        // ì‚¬ìš©ìê°€ ì •ì˜í•œ on_boss_defeated í•¨ìˆ˜ í˜¸ì¶œ
                        if (window.userCardSelector) {
                            const choice = window.userCardSelector(towerData, cardData);
                            if (choice && this.pendingCards.find(c => c.name === choice)) {
                                this.applyCard(choice);
                            } else {
                                // ì˜ëª»ëœ ì„ íƒì´ë©´ ì²« ë²ˆì§¸ ì¹´ë“œ ìë™ ì„ íƒ
                                log('ì˜ëª»ëœ ì¹´ë“œ ì„ íƒ! ì²« ë²ˆì§¸ ì¹´ë“œ ìë™ ì„ íƒ', 'warning');
                                this.applyCard(this.pendingCards[0].name);
                            }
                        } else {
                            // í•¨ìˆ˜ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ì¹´ë“œ ìë™ ì„ íƒ
                            this.applyCard(this.pendingCards[0].name);
                        }
                        return;
                    }
                    
                    const gameStateRef = this;
                    const towerAPI = {
                        ammo: Math.floor(this.ammo),
                        position: { x: this.tower.x, y: this.tower.y },
                        shoot: (zombie) => {
                            // ì¿¨ë‹¤ìš´ ì²´í¬!
                            if (gameStateRef.shootCooldown > 0) {
                                return; // ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ë°œì‚¬ ë¶ˆê°€
                            }
                            
                            // ì¢€ë¹„ ê°ì²´ì—ì„œ ì¸ë±ìŠ¤ ì°¾ê¸°
                            const zombieIndex = zombie.index;
                            const actualZombie = gameStateRef.zombies[zombieIndex];
                            
                            if (gameStateRef.ammo >= 1 && actualZombie && !actualZombie.dead) {
                                gameStateRef.ammo -= 1;
                                gameStateRef.shootCooldown = gameStateRef.shootCooldownTime; // ì¿¨ë‹¤ìš´ ì‹œì‘
                                gameStateRef.bullets.push({
                                    x: gameStateRef.tower.x,
                                    y: gameStateRef.tower.y,
                                    target: actualZombie,
                                    speed: 8,
                                    dead: false
                                });
                            }
                        }
                    };

                    const zombieData = this.zombies.map((z, index) => ({
                        distance: z.distance,
                        hp: z.hp,
                        type: z.type,
                        x: z.x,
                        y: z.y,
                        index: index,
                        isVulnerable: z.isVulnerable !== undefined ? z.isVulnerable : true  // vulnerable íƒ€ì…ë§Œ ì´ ì†ì„± ìˆìŒ
                    }));

                    userAI(towerAPI, zombieData);
                } catch (e) {
                    log(`AI ì—ëŸ¬: ${e.message}`, 'error');
                    stopGame();
                }
            }

            draw(ctx) {
                ctx.clearRect(0, 0, 600, 400);

                // ë°°ê²½
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, 600, 400);

                // ê·¸ë¦¬ë“œ
                ctx.strokeStyle = '#2e2e2e';
                ctx.lineWidth = 1;
                for (let i = 0; i < 600; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 400);
                    ctx.stroke();
                }
                for (let i = 0; i < 400; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(600, i);
                    ctx.stroke();
                }

                // íƒ€ì›Œ
                ctx.fillStyle = '#4ec9b0';
                ctx.fillRect(this.tower.x - 20, this.tower.y - 20, 40, 40);
                ctx.fillStyle = '#569cd6';
                ctx.fillRect(this.tower.x - 10, this.tower.y - 30, 20, 15);

                // ì¢€ë¹„ë“¤
                for (let zombie of this.zombies) {
                    // ì¢€ë¹„ íƒ€ì…ë³„ ìƒ‰ìƒê³¼ í¬ê¸°
                    let zombieColor;
                    let size = zombie.size || 30;
                    
                    if (zombie.type === 'boss') {
                        zombieColor = '#9b59b6';  // ë³´ë¼ìƒ‰
                        size = zombie.size || 60;
                    } else if (zombie.type === 'bonus') {
                        zombieColor = '#00ffff';  // ì‹œì•ˆ (ì²­ë¡ìƒ‰)
                    } else if (zombie.type === 'vulnerable') {
                        zombieColor = zombie.isVulnerable ? '#ff8800' : '#ffcc00';
                    } else {
                        zombieColor = zombie.hp > zombie.maxHp / 2 ? '#c72e2e' : '#8b0000';
                    }
                    
                    ctx.fillStyle = zombieColor;
                    ctx.fillRect(zombie.x - size/2, zombie.y - size/2, size, size);
                    
                    // HP ë°”
                    if (zombie.type === 'boss' || zombie.type === 'basic') {
                        ctx.fillStyle = '#3e3e42';
                        ctx.fillRect(zombie.x - size/2, zombie.y - size/2 - 10, size, 5);
                        ctx.fillStyle = '#4ec9b0';
                        ctx.fillRect(zombie.x - size/2, zombie.y - size/2 - 10, size * (zombie.hp / zombie.maxHp), 5);
                    } else if (zombie.type === 'vulnerable') {
                        // vulnerable ìƒíƒœ í‘œì‹œ
                        ctx.fillStyle = zombie.isVulnerable ? '#ff8800' : '#666666';
                        ctx.fillRect(zombie.x - 15, zombie.y - 25, 30, 5);
                    } else if (zombie.type === 'bonus') {
                        // ë³´ë„ˆìŠ¤ í‘œì‹œ (ë³„ ëª¨ì–‘ìœ¼ë¡œ?)
                        ctx.fillStyle = '#ffff00';
                        ctx.font = 'bold 20px Arial';
                        ctx.fillText('â­', zombie.x - 10, zombie.y - 20);
                    }
                }

                // íƒ„ì•½ë“¤
                for (let bullet of this.bullets) {
                    ctx.fillStyle = '#dcdcaa';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // UI ì—…ë°ì´íŠ¸
                document.getElementById('level').textContent = this.level;
                document.getElementById('ammo').textContent = Math.floor(this.ammo);
                document.getElementById('damage').textContent = this.damage;
                document.getElementById('score').textContent = this.score;
            }
        }

        // ë¡œê·¸ í•¨ìˆ˜
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const logClass = `log-${type}`;
            output.innerHTML += `<div class="${logClass}">[${timestamp}] ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        // Pyodide ì´ˆê¸°í™”
        async function initPyodide() {
            log('Pyodide ë¡œë”© ì¤‘...', 'info');
            pyodide = await loadPyodide();
            log('Pyodide ë¡œë”© ì™„ë£Œ!', 'success');
            document.getElementById('runBtn').disabled = false;
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!isRunning) return;

            gameState.update(window.userAIFunction);
            
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            gameState.draw(ctx);

            animationId = requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹¤í–‰
        async function runGame() {
            if (isRunning) return;

            const code = document.getElementById('codeEditor').value;
            
            try {
                log('ì½”ë“œ ì‹¤í–‰ ì¤‘...', 'info');
                
                await pyodide.runPythonAsync(code);
                
                // Python í•¨ìˆ˜ë¥¼ JavaScriptë¡œ ê°€ì ¸ì˜¤ê¸°
                window.userAIFunction = pyodide.globals.get('ai_logic').toJs();
                
                // ì¹´ë“œ ì„ íƒ í•¨ìˆ˜ (ìˆìœ¼ë©´ ê°€ì ¸ì˜¤ê¸°)
                try {
                    window.userCardSelector = pyodide.globals.get('on_boss_defeated').toJs();
                } catch (e) {
                    window.userCardSelector = null;
                    log('on_boss_defeated í•¨ìˆ˜ ì—†ìŒ - ìë™ ì„ íƒ', 'warning');
                }
                
                log('ì½”ë“œ ì‹¤í–‰ ì„±ê³µ! ê²Œì„ ì‹œì‘!', 'success');
                
                gameState = new GameState();
                isRunning = true;
                
                document.getElementById('runBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                gameLoop();
            } catch (e) {
                log(`ì—ëŸ¬: ${e.message}`, 'error');
                console.error(e);
            }
        }

        // ê²Œì„ ì •ì§€
        function stopGame() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            document.getElementById('runBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            log('ê²Œì„ ì •ì§€', 'warning');
        }

        // ë¦¬ì…‹
        function resetGame() {
            stopGame();
            gameState = new GameState();
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 400);
            document.getElementById('output').innerHTML = '';
            log('ê²Œì„ ë¦¬ì…‹ ì™„ë£Œ', 'info');
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('runBtn').addEventListener('click', runGame);
        document.getElementById('stopBtn').addEventListener('click', stopGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);

        // ì´ˆê¸°í™”
        initPyodide();
    </script>
</body>
</html>
