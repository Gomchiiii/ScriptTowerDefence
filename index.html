<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë©€í‹° íƒ€ì›Œ ë””íœìŠ¤ ì½”ë”© ê²Œì„</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 600px 1fr;
            gap: 20px;
        }
        
        .panel {
            background: #252526;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #3e3e42;
        }
        
        h1 {
            color: #4ec9b0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        h2 {
            color: #569cd6;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        #gameCanvas {
            width: 100%;
            background: #1e1e1e;
            border: 2px solid #4ec9b0;
            border-radius: 4px;
            display: block;
            cursor: pointer;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        
        .stat-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #4ec9b0;
            font-size: 20px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #1177bb;
        }
        
        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #c72e2e;
        }
        
        button.danger:hover {
            background: #e03e3e;
        }
        
        #output {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 150px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .log-info { color: #4ec9b0; }
        .log-error { color: #f48771; }
        .log-warning { color: #dcdcaa; }
        .log-success { color: #4ec9b0; }
        
        .script-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .script-tab {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            padding: 8px 16px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        
        .script-tab:hover {
            background: #2d2d30;
        }
        
        .script-tab.active {
            background: #0e639c;
            color: white;
            border-color: #0e639c;
        }
        
        .script-tab input {
            background: transparent;
            border: none;
            color: inherit;
            font-family: inherit;
            font-size: inherit;
            width: 100px;
            outline: none;
        }
        
        .script-tab .close {
            margin-left: 8px;
            color: #858585;
            cursor: pointer;
        }
        
        .script-tab .close:hover {
            color: #f48771;
        }
        
        #codeEditor {
            width: 100%;
            height: 500px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 0 4px 4px 4px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            color: #d4d4d4;
            resize: vertical;
            line-height: 1.5;
        }
        
        .tower-list {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .tower-item {
            padding: 10px;
            margin: 5px 0;
            background: #252526;
            border: 2px solid #3e3e42;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tower-item:hover {
            border-color: #4ec9b0;
        }
        
        .tower-item.selected {
            border-color: #0e639c;
            background: #0e639c22;
        }
        
        .tower-script-select {
            margin-top: 8px;
        }
        
        .tower-script-select select {
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #3e3e42;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: inherit;
            font-size: 12px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>ğŸ° ë©€í‹° íƒ€ì›Œ ë””íœìŠ¤</h1>
            
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            <p style="font-size: 12px; color: #858585; margin-top: 5px;">ğŸ’¡ íƒ€ì›Œë¥¼ í´ë¦­í•´ì„œ ì„ íƒí•˜ì„¸ìš”</p>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">ë ˆë²¨</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">íƒ„ì•½</div>
                    <div class="stat-value" id="ammo">100</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ë°ë¯¸ì§€</div>
                    <div class="stat-value" id="damage">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ì ìˆ˜</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
            
            <div id="upgradeDisplay" style="margin: 10px 0;">
                <strong style="color: #569cd6; font-size: 14px; margin-bottom: 8px; display: block;">ğŸ´ íšë“ ì—…ê·¸ë ˆì´ë“œ</strong>
                <div id="upgradeList" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 40px;">
                    <div style="color: #858585; font-size: 13px; padding: 8px;">ì—†ìŒ</div>
                </div>
            </div>
            
            <div class="controls">
                <button id="runBtn">â–¶ ì‹¤í–‰</button>
                <button id="stopBtn" class="danger" disabled>â–  ì •ì§€</button>
                <button id="pauseBtn" style="background: #d68a0e;" disabled>â¸ ì¼ì‹œì •ì§€</button>
                <button id="stepBtn" style="background: #569cd6;" disabled>â¡ 1í”„ë ˆì„</button>
                <button id="speedBtn" style="background: #4ec9b0;">âš¡ ì†ë„: 1x</button>
                <button id="resetBtn">â†» ë¦¬ì…‹</button>
            </div>
            
            <h2>ğŸ“‹ ë¡œê·¸</h2>
            <div id="output"></div>
        </div>
        
        <div class="panel">
            <h2>ğŸ° íƒ€ì›Œ ê´€ë¦¬</h2>
            <div class="tower-list" id="towerList"></div>
            
            <h2>ğŸ“– API ë¬¸ì„œ <button onclick="toggleApiDoc()" style="padding: 4px 12px; font-size: 12px; margin-left: 10px;">ì ‘ê¸° / í¼ì¹˜ê¸°</button></h2>
            <div id="apiDoc" style="background: #1e1e1e; border: 1px solid #3e3e42; border-radius: 4px; padding: 15px; margin-bottom: 15px; font-size: 13px; line-height: 1.8;">
                <strong style="color: #569cd6;">íƒ€ì›Œ AI í•¨ìˆ˜:</strong><br>
                <code style="color: #dcdcaa;">def ai_logic(tower, zombies):</code><br>
                <span style="color: #858585;">ë§¤ í”„ë ˆì„ë§ˆë‹¤ í˜¸ì¶œë¨</span><br><br>
                
                <strong style="color: #569cd6;">tower ê°ì²´:</strong><br>
                â€¢ <code>tower.ammo</code> - ë‚¨ì€ íƒ„ì•½<br>
                â€¢ <code>tower.position</code> - íƒ€ì›Œ ìœ„ì¹˜ {x, y}<br>
                â€¢ <code>tower.shoot(zombie)</code> - ì¢€ë¹„ ê³µê²©<br><br>
                
                <strong style="color: #569cd6;">zombie ê°ì²´:</strong><br>
                â€¢ <code>zombie.type</code> - 'basic', 'vulnerable', 'bonus', 'boss'<br>
                â€¢ <code>zombie.distance</code> - íƒ€ì›Œë¡œë¶€í„°ì˜ ê±°ë¦¬<br>
                â€¢ <code>zombie.hp</code> - í˜„ì¬ ì²´ë ¥<br>
                â€¢ <code>zombie.isVulnerable</code> - ê³µê²© ê°€ëŠ¥ ì—¬ë¶€ (vulnerable íƒ€ì…ë§Œ)<br><br>
                
                <strong style="color: #569cd6;">ì¢€ë¹„ ì¢…ë¥˜:</strong><br>
                ğŸ”´ <strong>basic</strong> - ê¸°ë³¸ ì¢€ë¹„ (HP: 1, ì ìˆ˜: 10)<br>
                ğŸŸ¡ <strong>vulnerable</strong> - ì£¼í™©ìƒ‰ì¼ ë•Œë§Œ ê³µê²© ê°€ëŠ¥ (ì ìˆ˜: 20)<br>
                ğŸ’ <strong>bonus</strong> - ì‹œì•ˆìƒ‰, ë¹ ë¦„, ì²˜ì¹˜ ì‹œ ë°ë¯¸ì§€ +1 (ì ìˆ˜: 50)<br>
                ğŸ‘¹ <strong>boss</strong> - 5ë ˆë²¨ë§ˆë‹¤ ì¶œí˜„, ê±°ëŒ€ ë³´ë¼ìƒ‰, HP 15+ (ì ìˆ˜: 100)<br><br>
                
                <strong style="color: #569cd6;">ìœ í‹¸ë¦¬í‹°:</strong><br>
                â€¢ <code>print("ë©”ì‹œì§€")</code> - ë¡œê·¸ì— ì¶œë ¥<br>
                â€¢ ì‚¬ê±°ë¦¬: 200 ì´ë‚´ì—ì„œë§Œ ê³µê²© ê°€ëŠ¥<br>
                â€¢ ë°œì‚¬ ì¿¨ë‹¤ìš´: 30í”„ë ˆì„ (0.5ì´ˆ)
            </div>
            
            <h2>ğŸ’» ìŠ¤í¬ë¦½íŠ¸ í¸ì§‘</h2>
            <button id="newScriptBtn" style="margin-bottom: 10px;">+ ìƒˆ ìŠ¤í¬ë¦½íŠ¸</button>
            
            <div class="script-tabs" id="scriptTabs"></div>
            <textarea id="codeEditor" spellcheck="false"># íƒ€ì›Œ AI ìŠ¤í¬ë¦½íŠ¸

def ai_logic(tower, zombies):
    if not zombies or tower.ammo <= 0:
        return
    
    in_range = [z for z in zombies if z.distance < 200]
    if not in_range:
        return
    
    # bonus ìš°ì„ 
    bonus = [z for z in in_range if z.type == 'bonus']
    if bonus:
        print("ë³´ë„ˆìŠ¤ ì¢€ë¹„ ë°œê²¬!")  # ë¡œê·¸ì— ì¶œë ¥!
        tower.shoot(min(bonus, key=lambda z: z.distance))
        return
    
    # ê°€ì¥ ê°€ê¹Œìš´ ì¢€ë¹„
    closest = min(in_range, key=lambda z: z.distance)
    tower.shoot(closest)
</textarea>
        </div>
    </div>

    <script>
        let pyodide = null;
        let gameState = null; // ë‚˜ì¤‘ì— ì´ˆê¸°í™”
        let animationId = null;
        let isRunning = false;
        let isPaused = false;
        let gameSpeed = 1; // 1x, 2x ì†ë„
        let debugMode = false;
        
        // ìŠ¤í¬ë¦½íŠ¸ ê´€ë¦¬
        let scripts = {
            'default': `# ê¸°ë³¸ AI
def ai_logic(tower, zombies):
    if not zombies or tower.ammo <= 0:
        return
    
    in_range = [z for z in zombies if z.distance < 200]
    if not in_range:
        return
    
    closest = min(in_range, key=lambda z: z.distance)
    print(f"[default] ê³µê²©: {closest.type} (ê±°ë¦¬: {closest.distance:.1f})")
    tower.shoot(closest)`,
            'tower2': `# ë³´ë„ˆìŠ¤ ìš°ì„  AI
def ai_logic(tower, zombies):
    if not zombies or tower.ammo <= 0:
        return
    
    in_range = [z for z in zombies if z.distance < 200]
    if not in_range:
        return
    
    # bonus ìš°ì„ 
    bonus = [z for z in in_range if z.type == 'bonus']
    if bonus:
        target = min(bonus, key=lambda z: z.distance)
        print(f"[tower2] ë³´ë„ˆìŠ¤ ë°œê²¬! ê³µê²©!")
        tower.shoot(target)
        return
    
    closest = min(in_range, key=lambda z: z.distance)
    tower.shoot(closest)`
        };
        
        let currentScript = 'default';
        let compiledScripts = {};

        class GameState {
            constructor() {
                this.level = 1;
                this.score = 0;
                this.ammo = 100;
                this.maxAmmo = 100;
                this.ammoRegenRate = 0.5;
                this.zombies = [];
                this.towers = [
                    { id: 0, x: 100, y: 150, scriptName: 'default', shootCooldown: 0 },
                    { id: 1, x: 100, y: 250, scriptName: 'tower2', shootCooldown: 0 }
                ];
                this.selectedTowerId = null;
                this.bullets = [];
                this.frameCount = 0;
                this.spawnTimer = 0;
                this.damage = 1;
                this.bossSpawned = false;
                this.selectedUpgrades = {};
            }

            spawnZombie() {
                if (this.level % 5 === 0 && !this.bossSpawned) {
                    this.zombies.push({
                        x: 600, y: 180, hp: 15 + this.level * 2, maxHp: 15 + this.level * 2,
                        speed: 0.2, type: 'boss', size: 60
                    });
                    this.bossSpawned = true;
                    log('ğŸ”¥ ë³´ìŠ¤ ì¶œí˜„!', 'warning');
                    return;
                }
                
                const rand = Math.random();
                if (rand < 0.1) {
                    this.zombies.push({ x: 600, y: 150 + Math.random() * 100, hp: 1, maxHp: 1, speed: 1.5, type: 'bonus' });
                } else if (rand < 0.35) {
                    this.zombies.push({ x: 600, y: 150 + Math.random() * 100, hp: 999, maxHp: 999, speed: 0.3, type: 'vulnerable', isVulnerable: false, vulnerableTimer: 0 });
                } else {
                    this.zombies.push({ x: 600, y: 150 + Math.random() * 100, hp: 1, maxHp: 1, speed: 0.5, type: 'basic' });
                }
            }

            update() {
                this.frameCount++;
                this.spawnTimer++;

                if (this.spawnTimer >= 120) {
                    this.spawnZombie();
                    this.spawnTimer = 0;
                }

                if (this.ammo < this.maxAmmo) {
                    this.ammo = Math.min(this.maxAmmo, this.ammo + this.ammoRegenRate);
                }

                // ì¢€ë¹„ ì´ë™
                for (let zombie of this.zombies) {
                    zombie.x -= zombie.speed;
                    
                    if (zombie.type === 'vulnerable') {
                        zombie.vulnerableTimer++;
                        if (zombie.vulnerableTimer >= 120) {
                            zombie.isVulnerable = !zombie.isVulnerable;
                            zombie.vulnerableTimer = 0;
                        }
                    }
                }

                // ê° íƒ€ì›Œë³„ë¡œ AI ì‹¤í–‰
                for (let tower of this.towers) {
                    if (tower.shootCooldown > 0) {
                        tower.shootCooldown--;
                    }
                    
                    // íƒ€ì›Œë³„ ê±°ë¦¬ ê³„ì‚°
                    const zombiesWithDistance = this.zombies.map((z, idx) => ({
                        ...z,
                        distance: Math.sqrt(Math.pow(z.x - tower.x, 2) + Math.pow(z.y - tower.y, 2)),
                        index: idx
                    }));

                    // íƒ€ì›Œ AI ì‹¤í–‰
                    const scriptFunc = compiledScripts[tower.scriptName];
                    if (scriptFunc) {
                        const towerAPI = {
                            ammo: Math.floor(this.ammo),
                            position: { x: tower.x, y: tower.y },
                            shoot: (zombie) => {
                                if (tower.shootCooldown > 0 || this.ammo < 1) return;
                                const actualZombie = this.zombies[zombie.index];
                                if (actualZombie && !actualZombie.dead) {
                                    this.ammo -= 1;
                                    tower.shootCooldown = 30;
                                    this.bullets.push({
                                        x: tower.x, y: tower.y,
                                        target: actualZombie,
                                        speed: 8
                                    });
                                }
                            }
                        };

                        try {
                            scriptFunc(towerAPI, zombiesWithDistance);
                        } catch (e) {
                            console.error(`Tower ${tower.id} AI error:`, e);
                        }
                    }
                }

                // íƒ„ì•½ ì´ë™
                for (let bullet of this.bullets) {
                    if (bullet.target && !bullet.target.dead) {
                        const dx = bullet.target.x - bullet.x;
                        const dy = bullet.target.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 5) {
                            if (bullet.target.type === 'vulnerable' && bullet.target.isVulnerable) {
                                bullet.target.dead = true;
                                this.score += 20;
                                this.ammo += 3;
                            } else if (bullet.target.type === 'bonus') {
                                bullet.target.hp -= this.damage;
                                if (bullet.target.hp <= 0) {
                                    bullet.target.dead = true;
                                    this.damage += 1;
                                    this.score += 50;
                                    log('ğŸ’¥ ë³´ë„ˆìŠ¤! ë°ë¯¸ì§€ +1', 'success');
                                }
                            } else if (bullet.target.type === 'boss') {
                                bullet.target.hp -= this.damage;
                                if (bullet.target.hp <= 0) {
                                    bullet.target.dead = true;
                                    this.score += 100;
                                    log('ğŸ† ë³´ìŠ¤ ì²˜ì¹˜!', 'success');
                                }
                            } else if (bullet.target.type !== 'vulnerable') {
                                bullet.target.hp -= this.damage;
                                if (bullet.target.hp <= 0) {
                                    bullet.target.dead = true;
                                    this.score += 10;
                                    this.ammo += 2;
                                }
                            }
                            bullet.dead = true;
                        } else {
                            bullet.x += (dx / dist) * bullet.speed;
                            bullet.y += (dy / dist) * bullet.speed;
                        }
                    } else {
                        bullet.dead = true;
                    }
                }

                this.zombies = this.zombies.filter(z => !z.dead && z.x > -50);
                this.bullets = this.bullets.filter(b => !b.dead);

                // ë ˆë²¨ì—…
                if (this.score > this.level * 100) {
                    this.level++;
                    if (this.level % 5 === 1) this.bossSpawned = false;
                }

                // ê²Œì„ì˜¤ë²„
                const escaped = this.zombies.filter(z => z.x < 50);
                if (escaped.length > 5) {
                    log('ê²Œì„ ì˜¤ë²„!', 'error');
                    stopGame();
                }
            }

            draw(ctx) {
                ctx.clearRect(0, 0, 600, 400);
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, 600, 400);

                // ê·¸ë¦¬ë“œ
                ctx.strokeStyle = '#2e2e2e';
                for (let i = 0; i < 600; i += 50) {
                    ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, 400); ctx.stroke();
                }
                for (let i = 0; i < 400; i += 50) {
                    ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(600, i); ctx.stroke();
                }

                // íƒ€ì›Œë“¤
                for (let tower of this.towers) {
                    const isSelected = tower.id === this.selectedTowerId;
                    ctx.fillStyle = isSelected ? '#0e639c' : '#4ec9b0';
                    ctx.fillRect(tower.x - 20, tower.y - 20, 40, 40);
                    ctx.fillStyle = '#569cd6';
                    ctx.fillRect(tower.x - 10, tower.y - 30, 20, 15);
                    
                    // ìŠ¤í¬ë¦½íŠ¸ ì´ë¦„ í‘œì‹œ
                    ctx.fillStyle = '#dcdcaa';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(tower.scriptName, tower.x, tower.y - 35);
                    
                    // ì„ íƒ í‘œì‹œ
                    if (isSelected) {
                        ctx.strokeStyle = '#0e639c';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(tower.x - 25, tower.y - 25, 50, 50);
                    }
                }

                // ì¢€ë¹„ë“¤
                for (let zombie of this.zombies) {
                    let color, size = zombie.size || 30;
                    if (zombie.type === 'boss') color = '#9b59b6';
                    else if (zombie.type === 'bonus') color = '#00ffff';
                    else if (zombie.type === 'vulnerable') color = zombie.isVulnerable ? '#ff8800' : '#ffcc00';
                    else color = '#c72e2e';
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(zombie.x - size/2, zombie.y - size/2, size, size);
                    
                    if (zombie.type === 'boss' || zombie.type === 'basic') {
                        ctx.fillStyle = '#3e3e42';
                        ctx.fillRect(zombie.x - size/2, zombie.y - size/2 - 10, size, 5);
                        ctx.fillStyle = '#4ec9b0';
                        ctx.fillRect(zombie.x - size/2, zombie.y - size/2 - 10, size * (zombie.hp / zombie.maxHp), 5);
                    }
                }

                // íƒ„ì•½ë“¤
                for (let bullet of this.bullets) {
                    ctx.fillStyle = '#dcdcaa';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // UI ì—…ë°ì´íŠ¸
                document.getElementById('level').textContent = this.level;
                document.getElementById('ammo').textContent = Math.floor(this.ammo);
                document.getElementById('damage').textContent = this.damage;
                document.getElementById('score').textContent = this.score;
            }
        }

        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            output.innerHTML += `<div class="log-${type}">[${timestamp}] ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }
        
        // log í•¨ìˆ˜ë¥¼ ì „ì—­ìœ¼ë¡œ ë…¸ì¶œ (Pythonì—ì„œ ì ‘ê·¼ ê°€ëŠ¥)
        window.log = log;

        async function initPyodide() {
            log('Pyodide ë¡œë”© ì¤‘...', 'info');
            pyodide = await loadPyodide();
            log('Pyodide ì¤€ë¹„ ì™„ë£Œ!', 'success');
            document.getElementById('runBtn').disabled = false;
        }

        function gameLoop() {
            if (!isRunning) return;
            
            // ì¼ì‹œì •ì§€ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ì—…ë°ì´íŠ¸
            if (!isPaused) {
                // ì†ë„ì— ë”°ë¼ ì—¬ëŸ¬ í”„ë ˆì„ ì‹¤í–‰
                for (let i = 0; i < gameSpeed; i++) {
                    gameState.update();
                }
            }
            
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            gameState.draw(ctx);
            
            animationId = requestAnimationFrame(gameLoop);
        }

        async function compileScripts() {
            compiledScripts = {};
            
            // Python print í•¨ìˆ˜ë¥¼ JavaScript logë¡œ ì—°ê²°
            pyodide.runPython(`
import sys
from js import log as js_log

class GameLogger:
    def write(self, text):
        if text.strip():
            js_log(text.strip(), 'info')
    
    def flush(self):
        pass

sys.stdout = GameLogger()
sys.stderr = GameLogger()
`);
            
            for (let [name, code] of Object.entries(scripts)) {
                try {
                    await pyodide.runPythonAsync(code);
                    compiledScripts[name] = pyodide.globals.get('ai_logic').toJs();
                } catch (e) {
                    log(`ìŠ¤í¬ë¦½íŠ¸ "${name}" ì»´íŒŒì¼ ì‹¤íŒ¨: ${e.message}`, 'error');
                }
            }
        }

        async function runGame() {
            if (isRunning) return;
            
            try {
                log('ìŠ¤í¬ë¦½íŠ¸ ì»´íŒŒì¼ ì¤‘...', 'info');
                await compileScripts();
                log('ê²Œì„ ì‹œì‘!', 'success');
                
                // gameStateëŠ” ì´ë¯¸ ì¡´ì¬í•˜ë¯€ë¡œ ë¦¬ì…‹ë§Œ
                gameState.zombies = [];
                gameState.bullets = [];
                gameState.frameCount = 0;
                gameState.spawnTimer = 0;
                gameState.score = 0;
                gameState.level = 1;
                gameState.ammo = 100;
                gameState.damage = 1;
                gameState.bossSpawned = false;
                
                isRunning = true;
                isPaused = false;
                
                document.getElementById('runBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stepBtn').disabled = false;
                
                gameLoop();
            } catch (e) {
                log(`ì—ëŸ¬: ${e.message}`, 'error');
            }
        }

        function stopGame() {
            isRunning = false;
            isPaused = false;
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('runBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'â¸ ì¼ì‹œì •ì§€';
            document.getElementById('stepBtn').disabled = true;
            log('ê²Œì„ ì •ì§€', 'warning');
        }

        function resetGame() {
            stopGame();
            gameState = new GameState();
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 400);
            document.getElementById('output').innerHTML = '';
            log('ê²Œì„ ë¦¬ì…‹', 'info');
        }

        // ìŠ¤í¬ë¦½íŠ¸ íƒ­ UI
        function renderScriptTabs() {
            const container = document.getElementById('scriptTabs');
            container.innerHTML = Object.keys(scripts).map(name => `
                <div class="script-tab ${name === currentScript ? 'active' : ''}" data-script="${name}">
                    <input type="text" value="${name}" onchange="renameScript('${name}', this.value)" onclick="event.stopPropagation()">
                    ${Object.keys(scripts).length > 1 ? `<span class="close" onclick="deleteScript('${name}'); event.stopPropagation()">Ã—</span>` : ''}
                </div>
            `).join('');
            
            document.querySelectorAll('.script-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    currentScript = tab.dataset.script;
                    document.getElementById('codeEditor').value = scripts[currentScript];
                    renderScriptTabs();
                });
            });
        }

        function renderTowerList() {
            const container = document.getElementById('towerList');
            
            container.innerHTML = gameState.towers.map(tower => `
                <div class="tower-item ${tower.id === gameState.selectedTowerId ? 'selected' : ''}" onclick="selectTower(${tower.id})">
                    <strong>íƒ€ì›Œ #${tower.id + 1}</strong> (${tower.x}, ${tower.y})
                    <div class="tower-script-select">
                        <select onchange="changeTowerScript(${tower.id}, this.value)" onclick="event.stopPropagation()">
                            ${Object.keys(scripts).map(name => 
                                `<option value="${name}" ${tower.scriptName === name ? 'selected' : ''}>${name}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            `).join('');
        }

        function selectTower(id) {
            gameState.selectedTowerId = id;
            renderTowerList();
            
            // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ì„ íƒ í‘œì‹œ)
            if (!isRunning) {
                const canvas = document.getElementById('gameCanvas');
                const ctx = canvas.getContext('2d');
                gameState.draw(ctx);
            }
        }

        function changeTowerScript(towerId, scriptName) {
            const tower = gameState.towers.find(t => t.id === towerId);
            if (tower) {
                tower.scriptName = scriptName;
                log(`íƒ€ì›Œ #${towerId + 1}ì˜ ìŠ¤í¬ë¦½íŠ¸ë¥¼ "${scriptName}"ìœ¼ë¡œ ë³€ê²½`, 'info');
                
                // ìº”ë²„ìŠ¤ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ìŠ¤í¬ë¦½íŠ¸ ì´ë¦„ í‘œì‹œ ì—…ë°ì´íŠ¸)
                if (!isRunning) {
                    const canvas = document.getElementById('gameCanvas');
                    const ctx = canvas.getContext('2d');
                    gameState.draw(ctx);
                }
            }
        }

        function renameScript(oldName, newName) {
            if (newName && newName !== oldName && !scripts[newName]) {
                scripts[newName] = scripts[oldName];
                delete scripts[oldName];
                if (currentScript === oldName) currentScript = newName;
                
                // íƒ€ì›Œ ìŠ¤í¬ë¦½íŠ¸ ì´ë¦„ë„ ë³€ê²½
                if (gameState) {
                    gameState.towers.forEach(t => {
                        if (t.scriptName === oldName) t.scriptName = newName;
                    });
                }
                
                renderScriptTabs();
                renderTowerList();
            }
        }

        function deleteScript(name) {
            if (Object.keys(scripts).length <= 1) return;
            delete scripts[name];
            if (currentScript === name) {
                currentScript = Object.keys(scripts)[0];
                document.getElementById('codeEditor').value = scripts[currentScript];
            }
            renderScriptTabs();
        }

        // ìº”ë²„ìŠ¤ í´ë¦­ìœ¼ë¡œ íƒ€ì›Œ ì„ íƒ
        document.getElementById('gameCanvas').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            for (let tower of gameState.towers) {
                if (Math.abs(x - tower.x) < 25 && Math.abs(y - tower.y) < 25) {
                    selectTower(tower.id);
                    return;
                }
            }
        });

        // ìƒˆ ìŠ¤í¬ë¦½íŠ¸ ì¶”ê°€
        document.getElementById('newScriptBtn').addEventListener('click', () => {
            const newName = `script${Object.keys(scripts).length + 1}`;
            scripts[newName] = `# ìƒˆ ìŠ¤í¬ë¦½íŠ¸
def ai_logic(tower, zombies):
    if not zombies or tower.ammo <= 0:
        return
    
    in_range = [z for z in zombies if z.distance < 200]
    if in_range:
        tower.shoot(min(in_range, key=lambda z: z.distance))`;
        currentScript = newName;
            document.getElementById('codeEditor').value = scripts[newName];
            renderScriptTabs();
        });
        
        // API ë¬¸ì„œ í† ê¸€
        function toggleApiDoc() {
            const doc = document.getElementById('apiDoc');
            if (doc.style.display === 'none') {
                doc.style.display = 'block';
            } else {
                doc.style.display = 'none';
            }
        }

        // ì½”ë“œ ì €ì¥
        document.getElementById('codeEditor').addEventListener('input', (e) => {
            scripts[currentScript] = e.target.value;
        });

        document.getElementById('runBtn').addEventListener('click', runGame);
        document.getElementById('stopBtn').addEventListener('click', stopGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);
        
        // ì¼ì‹œì •ì§€ ë²„íŠ¼
        document.getElementById('pauseBtn').addEventListener('click', () => {
            if (!isRunning) return;
            isPaused = !isPaused;
            const btn = document.getElementById('pauseBtn');
            if (isPaused) {
                btn.textContent = 'â–¶ ì¬ê°œ';
                log('ì¼ì‹œì •ì§€', 'warning');
            } else {
                btn.textContent = 'â¸ ì¼ì‹œì •ì§€';
                log('ì¬ê°œ', 'info');
            }
        });
        
        // 1í”„ë ˆì„ ì‹¤í–‰ ë²„íŠ¼
        document.getElementById('stepBtn').addEventListener('click', () => {
            if (!isRunning) return;
            
            // ì¼ì‹œì •ì§€ ìƒíƒœê°€ ì•„ë‹ˆë©´ ë¨¼ì € ì¼ì‹œì •ì§€
            if (!isPaused) {
                isPaused = true;
                document.getElementById('pauseBtn').textContent = 'â–¶ ì¬ê°œ';
            }
            
            // í•œ í”„ë ˆì„ë§Œ ì‹¤í–‰
            gameState.update();
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            gameState.draw(ctx);
            
            log(`í”„ë ˆì„ ${gameState.frameCount} ì‹¤í–‰`, 'info');
        });
        
        // ì†ë„ ë³€ê²½ ë²„íŠ¼
        document.getElementById('speedBtn').addEventListener('click', () => {
            if (gameSpeed === 1) {
                gameSpeed = 2;
                document.getElementById('speedBtn').textContent = 'âš¡ ì†ë„: 2x';
                log('ê²Œì„ ì†ë„ 2ë°°', 'success');
            } else {
                gameSpeed = 1;
                document.getElementById('speedBtn').textContent = 'âš¡ ì†ë„: 1x';
                log('ê²Œì„ ì†ë„ ì •ìƒ', 'info');
            }
        });

        // ì´ˆê¸°í™”
        gameState = new GameState(); // GameState í´ë˜ìŠ¤ ì •ì˜ í›„ ì´ˆê¸°í™”
        initPyodide();
        renderScriptTabs();
        renderTowerList();
        
        // ì´ˆê¸° ìº”ë²„ìŠ¤ ê·¸ë¦¬ê¸°
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        gameState.draw(ctx);
    </script>
</body>
</html>
