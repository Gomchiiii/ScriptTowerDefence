<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒ€ì›Œ ë””íœìŠ¤ ì½”ë”© ê²Œì„</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .panel {
            background: #252526;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #3e3e42;
        }
        
        h1 {
            color: #4ec9b0;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        h2 {
            color: #569cd6;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        #gameCanvas {
            width: 100%;
            background: #1e1e1e;
            border: 2px solid #4ec9b0;
            border-radius: 4px;
            display: block;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
        }
        
        .stat-label {
            color: #858585;
            font-size: 12px;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #4ec9b0;
            font-size: 20px;
            font-weight: bold;
        }
        
        #codeEditor {
            width: 100%;
            height: 400px;
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            color: #d4d4d4;
            resize: vertical;
            line-height: 1.5;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        
        button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #1177bb;
        }
        
        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #c72e2e;
        }
        
        button.danger:hover {
            background: #e03e3e;
        }
        
        #output {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .log-info {
            color: #4ec9b0;
        }
        
        .log-error {
            color: #f48771;
        }
        
        .log-warning {
            color: #dcdcaa;
        }
        
        .log-success {
            color: #4ec9b0;
        }
        
        .template-info {
            background: #1e1e1e;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #569cd6;
            margin-bottom: 15px;
            font-size: 13px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>ğŸ® íƒ€ì›Œ ë””íœìŠ¤ ì½”ë”© ê²Œì„</h1>
            
            <canvas id="gameCanvas" width="600" height="400"></canvas>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-label">ë ˆë²¨</div>
                    <div class="stat-value" id="level">1</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ë‚¨ì€ íƒ„ì•½</div>
                    <div class="stat-value" id="ammo">100</div>
                </div>
                <div class="stat">
                    <div class="stat-label">ì ìˆ˜</div>
                    <div class="stat-value" id="score">0</div>
                </div>
            </div>
            
            <div class="controls">
                <button id="runBtn">â–¶ ì‹¤í–‰</button>
                <button id="stopBtn" class="danger" disabled>â–  ì •ì§€</button>
                <button id="resetBtn">â†» ë¦¬ì…‹</button>
            </div>
            
            <h2>ğŸ“‹ ë¡œê·¸</h2>
            <div id="output"></div>
        </div>
        
        <div class="panel">
            <h2>ğŸ’» íŒŒì´ì¬ ì½”ë“œ</h2>
            
            <div class="template-info">
                <strong>ì‚¬ìš© ê°€ëŠ¥í•œ API:</strong><br>
                â€¢ <code>zombies</code> - ì¢€ë¹„ ë¦¬ìŠ¤íŠ¸ (distance, hp, type, isVulnerable, index)<br>
                â€¢ <code>zombie.type</code> - 'basic' ë˜ëŠ” 'vulnerable'<br>
                â€¢ <code>zombie.isVulnerable</code> - Trueì¼ ë•Œë§Œ ê³µê²© ê°€ëŠ¥ (vulnerable íƒ€ì…)<br>
                â€¢ <code>tower.shoot(index)</code> - ì¢€ë¹„ ì¸ë±ìŠ¤ë¡œ ê³µê²©<br>
                â€¢ <code>tower.ammo</code> - ë‚¨ì€ íƒ„ì•½<br>
                â€¢ <code>tower.position</code> - íƒ€ì›Œ ìœ„ì¹˜
            </div>
            
            <textarea id="codeEditor" spellcheck="false"># íƒ€ì›Œ AI ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”!

def ai_logic(tower, zombies):
    """
    ë§¤ í”„ë ˆì„ë§ˆë‹¤ í˜¸ì¶œë©ë‹ˆë‹¤.
    
    Args:
        tower: íƒ€ì›Œ ê°ì²´ (shoot ë©”ì„œë“œ ì‚¬ìš© ê°€ëŠ¥)
        zombies: ì¢€ë¹„ ë¦¬ìŠ¤íŠ¸
    """
    
    if not zombies or tower.ammo <= 0:
        return
    
    # ê°€ì¥ ê°€ê¹Œìš´ ì¢€ë¹„ ì°¾ê¸°
    closest = min(zombies, key=lambda z: z.distance)
    
    # ì‚¬ê±°ë¦¬ ì²´í¬
    if closest.distance >= 200:
        return
    
    # ì¢€ë¹„ íƒ€ì…ë³„ ì²˜ë¦¬
    if closest.type == 'basic':
        # ê¸°ë³¸ ì¢€ë¹„ëŠ” ë°”ë¡œ ê³µê²©
        tower.shoot(closest.index)
    elif closest.type == 'vulnerable':
        # vulnerable ì¢€ë¹„ëŠ” ê³µê²© ê°€ëŠ¥í•  ë•Œë§Œ!
        if closest.isVulnerable:
            tower.shoot(closest.index)

# ì—¬ê¸°ì„œë¶€í„° ì½”ë“œë¥¼ ìˆ˜ì •í•˜ì„¸ìš”!
# íŒíŠ¸: vulnerable ì¢€ë¹„ë¥¼ ìš°ì„  ê³µê²©í•˜ë©´ ì ìˆ˜ê°€ ë” ë†’ì•„ìš”!
</textarea>
        </div>
    </div>

    <script>
        let pyodide = null;
        let gameState = null;
        let animationId = null;
        let isRunning = false;

        // ê²Œì„ ìƒíƒœ í´ë˜ìŠ¤
        class GameState {
            constructor() {
                this.level = 1;
                this.score = 0;
                this.ammo = 100;
                this.maxAmmo = 100;
                this.ammoRegenRate = 0.5;
                this.zombies = [];
                this.tower = { x: 100, y: 200 };
                this.bullets = [];
                this.frameCount = 0;
                this.spawnTimer = 0;
                this.spawnInterval = 120;
                this.shootCooldown = 0;  // ë°œì‚¬ ì¿¨ë‹¤ìš´
                this.shootCooldownTime = 30;  // 0.5ì´ˆ (60fps ê¸°ì¤€)
            }

            spawnZombie() {
                // ëœë¤ìœ¼ë¡œ ì¢€ë¹„ íƒ€ì… ì„ íƒ (30% í™•ë¥ ë¡œ vulnerable)
                const isVulnerable = Math.random() < 0.3;
                
                if (isVulnerable) {
                    this.zombies.push({
                        x: 600,
                        y: 150 + Math.random() * 100,
                        hp: 999, // ì—„ì²­ ë†’ì€ HP (vulnerableí•  ë•Œë§Œ ì£½ìŒ)
                        maxHp: 999,
                        speed: 0.3 + this.level * 0.05,
                        type: 'vulnerable',
                        id: Date.now() + Math.random(),
                        isVulnerable: false, // ê³µê²© ê°€ëŠ¥ ìƒíƒœ
                        vulnerableTimer: 0,
                        vulnerableCycle: 120 // 2ì´ˆë§ˆë‹¤ í† ê¸€
                    });
                } else {
                    this.zombies.push({
                        x: 600,
                        y: 150 + Math.random() * 100,
                        hp: 1, // í•œ ë°©ì— ì£½ìŒ
                        maxHp: 1,
                        speed: 0.5 + this.level * 0.1,
                        type: 'basic',
                        id: Date.now() + Math.random()
                    });
                }
            }

            update(userAI) {
                this.frameCount++;
                this.spawnTimer++;
                
                // ë°œì‚¬ ì¿¨ë‹¤ìš´ ê°ì†Œ
                if (this.shootCooldown > 0) {
                    this.shootCooldown--;
                }

                // ì¢€ë¹„ ìŠ¤í°
                if (this.spawnTimer >= this.spawnInterval) {
                    this.spawnZombie();
                    this.spawnTimer = 0;
                }

                // íƒ„ì•½ ì¬ìƒ
                if (this.ammo < this.maxAmmo) {
                    this.ammo = Math.min(this.maxAmmo, this.ammo + this.ammoRegenRate);
                }

                // ì¢€ë¹„ ì´ë™
                for (let zombie of this.zombies) {
                    zombie.x -= zombie.speed;
                    zombie.distance = Math.sqrt(
                        Math.pow(zombie.x - this.tower.x, 2) +
                        Math.pow(zombie.y - this.tower.y, 2)
                    );
                    
                    // vulnerable íƒ€ì… ì¢€ë¹„ì˜ ìƒíƒœ í† ê¸€
                    if (zombie.type === 'vulnerable') {
                        zombie.vulnerableTimer++;
                        if (zombie.vulnerableTimer >= zombie.vulnerableCycle) {
                            zombie.isVulnerable = !zombie.isVulnerable;
                            zombie.vulnerableTimer = 0;
                        }
                    }
                }

                // íƒ„ì•½ ì´ë™
                for (let bullet of this.bullets) {
                    if (bullet.target && !bullet.target.dead) {
                        const dx = bullet.target.x - bullet.x;
                        const dy = bullet.target.y - bullet.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 5) {
                            // vulnerable íƒ€ì…ì€ ê³µê²© ê°€ëŠ¥ ìƒíƒœì¼ ë•Œë§Œ ë°ë¯¸ì§€
                            if (bullet.target.type === 'vulnerable') {
                                if (bullet.target.isVulnerable) {
                                    bullet.target.dead = true;
                                    this.score += 20; // ë” ë§ì€ ì ìˆ˜
                                    this.ammo += 3;
                                    log('Vulnerable ì¢€ë¹„ ì²˜ì¹˜! (ê³µê²© ê°€ëŠ¥ ìƒíƒœ)', 'success');
                                } else {
                                    log('ê³µê²© ì‹¤íŒ¨! ì¢€ë¹„ê°€ ë¬´ì  ìƒíƒœì…ë‹ˆë‹¤.', 'warning');
                                }
                            } else {
                                // ì¼ë°˜ ì¢€ë¹„ëŠ” ê·¸ëƒ¥ ë°ë¯¸ì§€
                                bullet.target.hp -= 1;
                                if (bullet.target.hp <= 0) {
                                    bullet.target.dead = true;
                                    this.score += 10;
                                    this.ammo += 2;
                                }
                            }
                            bullet.dead = true;
                        } else {
                            bullet.x += (dx / dist) * bullet.speed;
                            bullet.y += (dy / dist) * bullet.speed;
                        }
                    } else {
                        bullet.dead = true;
                    }
                }

                // ì£½ì€ ê°ì²´ ì œê±°
                this.zombies = this.zombies.filter(z => !z.dead && z.x > -50);
                this.bullets = this.bullets.filter(b => !b.dead);

                // ê²Œì„ ì˜¤ë²„ ì²´í¬
                const escaped = this.zombies.filter(z => z.x < this.tower.x);
                if (escaped.length > 5) {
                    log('ê²Œì„ ì˜¤ë²„! ì¢€ë¹„ë“¤ì´ íƒ€ì›Œì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤!', 'error');
                    stopGame();
                    return;
                }

                // ë ˆë²¨ì—… ì²´í¬
                if (this.score > this.level * 100) {
                    this.level++;
                    log(`ë ˆë²¨ ${this.level}! ì¢€ë¹„ê°€ ë” ê°•í•´ì§‘ë‹ˆë‹¤!`, 'success');
                }

                // ì‚¬ìš©ì AI ì‹¤í–‰
                try {
                    const gameStateRef = this;
                    const towerAPI = {
                        ammo: Math.floor(this.ammo),
                        position: { x: this.tower.x, y: this.tower.y },
                        shoot: (zombieIndex) => {
                            // ì¿¨ë‹¤ìš´ ì²´í¬!
                            if (gameStateRef.shootCooldown > 0) {
                                return; // ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ë°œì‚¬ ë¶ˆê°€
                            }
                            
                            // ì¸ë±ìŠ¤ë¡œ ì§ì ‘ ì°¾ê¸°
                            const zombie = gameStateRef.zombies[zombieIndex];
                            if (gameStateRef.ammo >= 1 && zombie && !zombie.dead) {
                                gameStateRef.ammo -= 1;
                                gameStateRef.shootCooldown = gameStateRef.shootCooldownTime; // ì¿¨ë‹¤ìš´ ì‹œì‘
                                gameStateRef.bullets.push({
                                    x: gameStateRef.tower.x,
                                    y: gameStateRef.tower.y,
                                    target: zombie,
                                    speed: 8,
                                    dead: false
                                });
                            }
                        }
                    };

                    const zombieData = this.zombies.map((z, index) => ({
                        distance: z.distance,
                        hp: z.hp,
                        type: z.type,
                        x: z.x,
                        y: z.y,
                        index: index,
                        isVulnerable: z.isVulnerable !== undefined ? z.isVulnerable : true  // vulnerable íƒ€ì…ë§Œ ì´ ì†ì„± ìˆìŒ
                    }));

                    userAI(towerAPI, zombieData);
                } catch (e) {
                    log(`AI ì—ëŸ¬: ${e.message}`, 'error');
                    stopGame();
                }
            }

            draw(ctx) {
                ctx.clearRect(0, 0, 600, 400);

                // ë°°ê²½
                ctx.fillStyle = '#1e1e1e';
                ctx.fillRect(0, 0, 600, 400);

                // ê·¸ë¦¬ë“œ
                ctx.strokeStyle = '#2e2e2e';
                ctx.lineWidth = 1;
                for (let i = 0; i < 600; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 400);
                    ctx.stroke();
                }
                for (let i = 0; i < 400; i += 50) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(600, i);
                    ctx.stroke();
                }

                // íƒ€ì›Œ
                ctx.fillStyle = '#4ec9b0';
                ctx.fillRect(this.tower.x - 20, this.tower.y - 20, 40, 40);
                ctx.fillStyle = '#569cd6';
                ctx.fillRect(this.tower.x - 10, this.tower.y - 30, 20, 15);

                // ì¢€ë¹„ë“¤
                for (let zombie of this.zombies) {
                    // ì¢€ë¹„ íƒ€ì…ë³„ ìƒ‰ìƒ
                    let zombieColor;
                    if (zombie.type === 'vulnerable') {
                        zombieColor = zombie.isVulnerable ? '#ff8800' : '#ffcc00'; // ì£¼í™©/ë…¸ë‘
                    } else {
                        zombieColor = zombie.hp > zombie.maxHp / 2 ? '#c72e2e' : '#8b0000';
                    }
                    
                    ctx.fillStyle = zombieColor;
                    ctx.fillRect(zombie.x - 15, zombie.y - 15, 30, 30);
                    
                    // HP ë°” (vulnerable íƒ€ì…ì€ í‘œì‹œ ì•ˆí•¨)
                    if (zombie.type !== 'vulnerable') {
                        ctx.fillStyle = '#3e3e42';
                        ctx.fillRect(zombie.x - 15, zombie.y - 25, 30, 5);
                        ctx.fillStyle = '#4ec9b0';
                        ctx.fillRect(zombie.x - 15, zombie.y - 25, 30 * (zombie.hp / zombie.maxHp), 5);
                    } else {
                        // vulnerable ìƒíƒœ í‘œì‹œ
                        ctx.fillStyle = zombie.isVulnerable ? '#ff8800' : '#666666';
                        ctx.fillRect(zombie.x - 15, zombie.y - 25, 30, 5);
                    }
                }

                // íƒ„ì•½ë“¤
                for (let bullet of this.bullets) {
                    ctx.fillStyle = '#dcdcaa';
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // UI ì—…ë°ì´íŠ¸
                document.getElementById('level').textContent = this.level;
                document.getElementById('ammo').textContent = Math.floor(this.ammo);
                document.getElementById('score').textContent = this.score;
            }
        }

        // ë¡œê·¸ í•¨ìˆ˜
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const logClass = `log-${type}`;
            output.innerHTML += `<div class="${logClass}">[${timestamp}] ${message}</div>`;
            output.scrollTop = output.scrollHeight;
        }

        // Pyodide ì´ˆê¸°í™”
        async function initPyodide() {
            log('Pyodide ë¡œë”© ì¤‘...', 'info');
            pyodide = await loadPyodide();
            log('Pyodide ë¡œë”© ì™„ë£Œ!', 'success');
            document.getElementById('runBtn').disabled = false;
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!isRunning) return;

            gameState.update(window.userAIFunction);
            
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            gameState.draw(ctx);

            animationId = requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹¤í–‰
        async function runGame() {
            if (isRunning) return;

            const code = document.getElementById('codeEditor').value;
            
            try {
                log('ì½”ë“œ ì‹¤í–‰ ì¤‘...', 'info');
                
                await pyodide.runPythonAsync(code);
                
                // Python í•¨ìˆ˜ë¥¼ JavaScriptë¡œ ê°€ì ¸ì˜¤ê¸°
                window.userAIFunction = pyodide.globals.get('ai_logic').toJs();
                
                log('ì½”ë“œ ì‹¤í–‰ ì„±ê³µ! ê²Œì„ ì‹œì‘!', 'success');
                
                gameState = new GameState();
                isRunning = true;
                
                document.getElementById('runBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                gameLoop();
            } catch (e) {
                log(`ì—ëŸ¬: ${e.message}`, 'error');
                console.error(e);
            }
        }

        // ê²Œì„ ì •ì§€
        function stopGame() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            document.getElementById('runBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            log('ê²Œì„ ì •ì§€', 'warning');
        }

        // ë¦¬ì…‹
        function resetGame() {
            stopGame();
            gameState = new GameState();
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 600, 400);
            document.getElementById('output').innerHTML = '';
            log('ê²Œì„ ë¦¬ì…‹ ì™„ë£Œ', 'info');
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('runBtn').addEventListener('click', runGame);
        document.getElementById('stopBtn').addEventListener('click', stopGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);

        // ì´ˆê¸°í™”
        initPyodide();
    </script>
</body>
</html>
